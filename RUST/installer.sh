#!/usr/bin/env bash
# installer.sh - SFT system-wide client installer
#
# Installs:
#   /usr/local/bin/sft       client command with simplified syntax
#   /etc/profile.d/sft.sh    Docker management aliases (all users, all shells)
#
# Usage:
#   bash installer.sh            install / update
#   bash installer.sh --uninstall  remove sft command and aliases

set -euo pipefail

SFT_DIR="$(cd "$(dirname "$(readlink -f "$0")")" && pwd)"
VENV="$SFT_DIR/venv"
PYTHON="$VENV/bin/python3"
SFT_PY="$SFT_DIR/sft.py"
# Install locations: system-wide if sudo available, user-local otherwise
if sudo -n true 2>/dev/null; then
    INSTALL_BIN="/usr/local/bin/sft"
    PROFILE_D="/etc/profile.d/sft.sh"
    USE_SUDO=1
else
    INSTALL_BIN="$HOME/.local/bin/sft"
    PROFILE_D="$HOME/.local/share/sft-aliases.sh"
    USE_SUDO=0
fi

RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; NC='\033[0m'
ok()   { echo -e "${GREEN}[ OK ]${NC} $*"; }
info() { echo -e "${YELLOW}[INFO]${NC} $*"; }
die()  { echo -e "${RED}[ERR ]${NC} $*" >&2; exit 1; }

# ---------------------------------------------------------------------------
# Uninstall
# ---------------------------------------------------------------------------
if [[ "${1:-}" == "--uninstall" ]]; then
    info "Removing $INSTALL_BIN ..."
    sudo rm -f "$INSTALL_BIN" && ok "Removed $INSTALL_BIN"
    sudo rm -f "$PROFILE_D"   && ok "Removed $PROFILE_D"
    echo "venv and source files left intact in $SFT_DIR"
    exit 0
fi

# ---------------------------------------------------------------------------
# Sanity checks
# ---------------------------------------------------------------------------
[[ -f "$SFT_PY" ]] || die "sft.py not found in $SFT_DIR — run installer.sh from the RUST/ directory"
command -v python3 &>/dev/null || die "python3 not found in PATH"

# ---------------------------------------------------------------------------
# 1. Virtual environment
# ---------------------------------------------------------------------------
if [[ ! -f "$PYTHON" ]]; then
    info "Creating virtual environment at $VENV ..."
    python3 -m venv "$VENV"
    ok "venv created."
else
    ok "venv present: $PYTHON"
fi

info "Installing Python dependencies ..."
"$PYTHON" -m pip install --quiet --upgrade pip
"$PYTHON" -m pip install --quiet -r "$SFT_DIR/requirements.txt"
ok "Dependencies ready."

# ---------------------------------------------------------------------------
# 2. Rust crypto module (optional — pure Python fallback if unavailable)
# ---------------------------------------------------------------------------
if command -v cargo &>/dev/null; then
    info "Compiling Rust crypto module ..."
    (cd "$SFT_DIR" && "$PYTHON" python_wrapper.py --compile 2>/dev/null) \
        && ok "Rust module compiled." \
        || info "Rust module skipped — pure Python fallback will be used."
else
    info "cargo not found — skipping Rust module (pure Python mode)."
fi

# ---------------------------------------------------------------------------
# 3. Generate /usr/local/bin/sft wrapper
#    Paths are embedded at install time via sed placeholder substitution.
# ---------------------------------------------------------------------------
info "Generating $INSTALL_BIN ..."
TMP="$(mktemp)"

cat > "$TMP" << 'WRAPPER'
#!/usr/bin/env bash
# sft - Secure File Transfer client
# Generated by installer.sh — re-run installer to update embedded paths.
#
# SIMPLIFIED SYNTAX:
#   sft [-p PORT] IP /local/file              push local file to server
#   sft -u [-p PORT] IP:/remote/path /local   pull file from server
#   sft -l [-p PORT] IP                       list files on server
#
# ORIGINAL sft.py SYNTAX (pass-through — triggered by -m / --mode):
#   sft -m client -c IP:PORT -f /local/file
#   sft -m server [-H 0.0.0.0] [-p 5555]

PYTHON_BIN="__PYTHON__"
SFT_PY="__SFT_PY__"
DEFAULT_PORT=5555

usage() {
    cat << 'EOF'
sft — Secure File Transfer client

USAGE:
  sft [-p PORT] IP /local/file              push local file to server
  sft -u [-p PORT] IP:/remote/path /local   pull file from server
  sft -l [-p PORT] IP                       list files on server

OPTIONS:
  -p PORT    Port (default: 5555)
  -u         Pull / download mode
  -l         List remote files
  --help     Show this help

EXAMPLES:
  sft 192.168.3.202 /home/user/document.pdf
  sft -p 5554 192.168.3.202 /home/user/document.pdf
  sft -u 192.168.3.202:/ubuntu.iso /tmp/
  sft -l 192.168.3.202

ORIGINAL SYNTAX (use -m/--mode to trigger pass-through to sft.py):
  sft -m client -c 192.168.3.202:5555 -f /path/to/file
  sft -m server -p 5555
EOF
    exit 0
}

# Fast path: if --mode or -m is present anywhere, forward everything to sft.py unchanged.
for _arg in "$@"; do
    if [[ "$_arg" == "--mode" || "$_arg" == "-m" ]]; then
        exec "$PYTHON_BIN" "$SFT_PY" "$@"
    fi
done

PORT=$DEFAULT_PORT
DO_LIST=0
DO_PULL=0
POSITIONAL=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        -p|--port)  PORT="${2:?'error: -p requires a port number'}"; shift 2 ;;
        -l|--list)  DO_LIST=1; shift ;;
        -u|--pull)  DO_PULL=1; shift ;;
        --help)     usage ;;
        --)         shift; POSITIONAL+=("$@"); break ;;
        -*)         echo "Unknown option: $1" >&2; usage ;;
        *)          POSITIONAL+=("$1"); shift ;;
    esac
done

TARGET="${POSITIONAL[0]:-}"
LOCAL_PATH="${POSITIONAL[1]:-}"

[[ -z "$TARGET" ]] && { echo "Error: no target specified." >&2; usage; }

# Parse TARGET: bare IP  or  IP:/remote/path  (colon only valid with leading slash)
if [[ "$TARGET" =~ ^([^:]+):(/[^:]*)$ ]]; then
    HOST="${BASH_REMATCH[1]}"
    REMOTE_PATH="${BASH_REMATCH[2]}"
else
    HOST="$TARGET"
    REMOTE_PATH=""
fi

if [[ $DO_LIST -eq 1 ]]; then
    exec "$PYTHON_BIN" "$SFT_PY" -m client -c "${HOST}:${PORT}" -l

elif [[ $DO_PULL -eq 1 ]]; then
    if [[ -z "$REMOTE_PATH" ]]; then
        echo "Error: pull (-u) requires target in format IP:/remote/path" >&2
        exit 1
    fi
    exec "$PYTHON_BIN" "$SFT_PY" -m client -c "${HOST}:${PORT}" \
        -d "$REMOTE_PATH" -o "${LOCAL_PATH:-.}"

else
    # Push (default): LOCAL_PATH is the file to send.
    # If user wrote ip:/remote /local, LOCAL_PATH wins; REMOTE_PATH is informational only
    # (server controls destination directory — remote path not used in push).
    LOCAL_FILE="${LOCAL_PATH:-$REMOTE_PATH}"
    if [[ -z "$LOCAL_FILE" ]]; then
        echo "Error: specify a local file to push." >&2
        usage
    fi
    exec "$PYTHON_BIN" "$SFT_PY" -m client -c "${HOST}:${PORT}" -f "$LOCAL_FILE"
fi
WRAPPER

# Embed real paths
sed -i "s|__PYTHON__|${PYTHON}|g" "$TMP"
sed -i "s|__SFT_PY__|${SFT_PY}|g"  "$TMP"

mkdir -p "$(dirname "$INSTALL_BIN")"
if [[ $USE_SUDO -eq 1 ]]; then
    sudo mv "$TMP" "$INSTALL_BIN"
    sudo chmod 755 "$INSTALL_BIN"
else
    mv "$TMP" "$INSTALL_BIN"
    chmod 755 "$INSTALL_BIN"
    # Ensure ~/.local/bin is in PATH
    if ! grep -q 'LOCAL_BIN_ADDED_BY_SFT' "$HOME/.bashrc" 2>/dev/null; then
        cat >> "$HOME/.bashrc" << 'PATHBLOCK'

# Added by SFT installer — LOCAL_BIN_ADDED_BY_SFT
export PATH="$HOME/.local/bin:$PATH"
PATHBLOCK
        info "Added ~/.local/bin to PATH in ~/.bashrc (run: source ~/.bashrc)"
    fi
fi
ok "sft installed: $INSTALL_BIN"

# ---------------------------------------------------------------------------
# 4. Docker management aliases
#    System-wide via /etc/profile.d/ if sudo; user-local via ~/.bashrc otherwise.
# ---------------------------------------------------------------------------
info "Installing Docker management aliases ..."
ALIASES_CONTENT='# SFT Docker management aliases — generated by installer.sh
alias sft-build='"'"'docker build -t sft-rust:alpine .'"'"'
alias sft-up='"'"'docker compose up -d'"'"'
alias sft-down='"'"'docker compose down'"'"'
alias sft-logs='"'"'docker logs -f sft-server'"'"'
alias sft-shell='"'"'docker exec -it sft-server sh'"'"'
alias sft-restart='"'"'docker restart sft-server'"'"'
alias sft-ps='"'"'docker ps | grep sft'"'"'
alias sft-clean='"'"'docker system prune -f'"'"''

if [[ $USE_SUDO -eq 1 ]]; then
    mkdir -p "$(dirname "$PROFILE_D")"
    echo "$ALIASES_CONTENT" | sudo tee "$PROFILE_D" > /dev/null
    sudo chmod 644 "$PROFILE_D"
    ok "Aliases installed system-wide: $PROFILE_D"
else
    PROFILE_D="$HOME/.bashrc"
    if ! grep -q 'sft-build' "$HOME/.bashrc" 2>/dev/null; then
        echo "" >> "$HOME/.bashrc"
        echo "# SFT Docker management aliases — generated by installer.sh" >> "$HOME/.bashrc"
        echo "$ALIASES_CONTENT" >> "$HOME/.bashrc"
        ok "Aliases appended to $HOME/.bashrc"
    else
        ok "Aliases already present in $HOME/.bashrc (skipped)"
    fi
fi

# ---------------------------------------------------------------------------
# Summary
# ---------------------------------------------------------------------------
echo ""
echo -e "${GREEN}=================================================${NC}"
echo -e "${GREEN}  SFT client installed successfully${NC}"
echo -e "${GREEN}=================================================${NC}"
echo ""
echo "  Command : $INSTALL_BIN"
echo "  Python  : $PYTHON"
echo "  sft.py  : $SFT_PY"
echo ""
echo "  sft 192.168.3.202 /path/to/file          push"
echo "  sft -p 5554 192.168.3.202 /path/to/file  custom port"
echo "  sft -u 192.168.3.202:/file.iso /tmp/      pull"
echo "  sft -l 192.168.3.202                      list"
echo ""
echo "Docker aliases active in new shells. To load in current shell:"
echo "  source $PROFILE_D"
echo ""
if [[ $USE_SUDO -eq 0 ]]; then
    echo "Installed in user-local mode (no sudo available)."
    echo "To install system-wide, run with sudo privileges:"
    echo "  sudo bash $SFT_DIR/installer.sh"
    echo ""
fi
echo "To uninstall:"
echo "  bash $SFT_DIR/installer.sh --uninstall"
